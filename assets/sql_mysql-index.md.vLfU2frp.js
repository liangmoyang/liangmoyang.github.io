import{_ as a,o as e,c as l,R as i}from"./chunks/framework.LBXiIpgL.js";const b=JSON.parse('{"title":"Index 索引","description":"","frontmatter":{},"headers":[],"relativePath":"sql/mysql-index.md","filePath":"sql/mysql-index.md"}'),t={name:"sql/mysql-index.md"},r=i('<h1 id="index-索引" tabindex="-1">Index 索引 <a class="header-anchor" href="#index-索引" aria-label="Permalink to &quot;Index 索引&quot;">​</a></h1><h2 id="索引类型" tabindex="-1">索引类型 <a class="header-anchor" href="#索引类型" aria-label="Permalink to &quot;索引类型&quot;">​</a></h2><ul><li>普通索引：normal</li><li>唯一索引：unique</li><li>主键索引：primary key</li><li>全文索引：fulltext</li><li>空间索引：spatial</li></ul><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><ul><li><b>无论是表中的数据（主键索引）还是辅助索引最终都会使用B+树来存储数据，其中前者在表中会以<code>&lt;id,row&gt;</code>的方式存储，后者以<code>&lt;index,id&gt;</code>的方式进行存储。</b></li><li>页（默认16KB）：MySQL将数据划分到多个页中。每个页都记录了页号，数据页之间构成了双向链表结构。页内的结构是单向链表。</li><li>页目录：使用二分查找。</li><li>回表：先从二级索引中根据查询条件字段查找对应的主键id，之后再根据主键id去到聚簇索引查到完整的数据行。</li><li>索引覆盖：需要查询的字段都在索引列中，则不必回表查询。</li><li>索引下推：把服务层负责的事情，交给引擎层梳理，可以减少回表的次数，减少IO操作。</li><li>索引合并：explain-index_merge。</li><li>索引字段要设置<code>not null</code></li></ul><h2 id="b-树" tabindex="-1">B+树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B+树&quot;">​</a></h2><p>MySQL的B+树结构一般只需三层就可以放得下几千万行数据。</p><h2 id="聚簇索引" tabindex="-1">聚簇索引 <a class="header-anchor" href="#聚簇索引" aria-label="Permalink to &quot;聚簇索引&quot;">​</a></h2><p>叶子节点存储实际的数据的B+树被称为聚簇索引。非叶子节点存储的就是记录的ID和对应的索引页号。对于InnoDB，数据本身就存储在一棵B+树中。</p><h2 id="非聚簇索引-二级索引" tabindex="-1">非聚簇索引（二级索引） <a class="header-anchor" href="#非聚簇索引-二级索引" aria-label="Permalink to &quot;非聚簇索引（二级索引）&quot;">​</a></h2><p>本身也是B+树，叶子节点存储的是索引列的数据和对应的主键ID。非叶子结点，除了上述的之外，还存放了索引列的页号。</p><h2 id="聚簇和非聚簇的区别" tabindex="-1">聚簇和非聚簇的区别 <a class="header-anchor" href="#聚簇和非聚簇的区别" aria-label="Permalink to &quot;聚簇和非聚簇的区别&quot;">​</a></h2><p>聚簇索引的叶子节点存的是所有列的值，非聚簇索引的叶子节点只存了索引列的值和主键ID。</p><h2 id="update时的锁" tabindex="-1">Update时的锁 <a class="header-anchor" href="#update时的锁" aria-label="Permalink to &quot;Update时的锁&quot;">​</a></h2><p>加锁的情况分为：有索引、无索引。</p><h4 id="有索引" tabindex="-1">有索引 <a class="header-anchor" href="#有索引" aria-label="Permalink to &quot;有索引&quot;">​</a></h4><p>直接在索引树中找到这行数据，然后加上行锁。</p><h4 id="无索引" tabindex="-1">无索引 <a class="header-anchor" href="#无索引" aria-label="Permalink to &quot;无索引&quot;">​</a></h4><ol><li>注意，并不是加表锁，而是为所有的行加<b>行锁</b></li><li>然后进行逐行过滤，不满足条件的行就解锁，最终留下符合条件的行。</li></ol><h2 id="安全更新模式" tabindex="-1">安全更新模式 <a class="header-anchor" href="#安全更新模式" aria-label="Permalink to &quot;安全更新模式&quot;">​</a></h2><p>参数<code>sql_safe_updates</code>设置为1，则需要满足下列之一才能执行。</p><ul><li>where中必须有索引列</li><li>有limit</li><li>where+limit，此时可以没有索引列。</li></ul><h2 id="hash索引" tabindex="-1">Hash索引 <a class="header-anchor" href="#hash索引" aria-label="Permalink to &quot;Hash索引&quot;">​</a></h2><p>InnoDB不支持显式地创建Hash索引，只支持自适应Hash索引。可以用sql语句显式声明Hash索引，但其实是不生效的，最终还是btree。</p><p>Memory引擎支持Hash索引。</p><h2 id="文章推荐-参考" tabindex="-1">文章推荐/参考 <a class="header-anchor" href="#文章推荐-参考" aria-label="Permalink to &quot;文章推荐/参考&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/z89A3-_Q-VMqI7vVSlsulg" target="_blank" rel="noreferrer">聊聊索引</a></li></ul>',27),o=[r];function h(d,n,s,c,u,p){return e(),l("div",null,o)}const m=a(t,[["render",h]]);export{b as __pageData,m as default};
