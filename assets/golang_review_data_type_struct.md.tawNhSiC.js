import{_ as a,o as e,c as l,R as t}from"./chunks/framework.LBXiIpgL.js";const g=JSON.parse('{"title":"struct 结构体","description":"","frontmatter":{},"headers":[],"relativePath":"golang_review/data_type/struct.md","filePath":"golang_review/data_type/struct.md"}'),s={name:"golang_review/data_type/struct.md"},n=t(`<h1 id="struct-结构体" tabindex="-1">struct 结构体 <a class="header-anchor" href="#struct-结构体" aria-label="Permalink to &quot;struct 结构体&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><ul><li>结构体的成员变量在内存存储上是一段<b>连续</b>的内存</li><li>结构体的初始地址就是第一个成员变量的内存地址 <ul><li>基于结构体的成员地址去计算偏移量，就能够得出其他成员变量的地址。（反射应用）</li></ul></li><li>声明一个结构体时，就已经分配好了内存地址。</li><li>是否可比较：如果成员中包含不可比较类型，则结构体不可比较。如：map、slice、interface等。</li><li>空结构体不占用任何空间，并且都指向同一地址，这是Golang的特殊处理。但空结构体的指针，仍占8字节。</li></ul><h2 id="方法集" tabindex="-1">方法集 <a class="header-anchor" href="#方法集" aria-label="Permalink to &quot;方法集&quot;">​</a></h2><ul><li>值类型方法 <ul><li>值实例，只能调用值类型方法</li></ul></li><li>指针类型方法 <ul><li>指针实例，可以调用值类型和指针类型方法 但在实际开发中，值实例可以调用指针类型方法，这是golang做了优化。（但涉及到interface实现的话，会有所区分）</li></ul></li></ul><h2 id="自引用" tabindex="-1">自引用 <a class="header-anchor" href="#自引用" aria-label="Permalink to &quot;自引用&quot;">​</a></h2><p>结构体的自引用只能使用指针。结构体声明时要计算大小，如果不适用指针会导致循环分配导致内存溢出。 应用举例：二叉树结构定义：</p><div class="language-golang vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">golang</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">type Node struct{</span></span>
<span class="line"><span style="color:#e1e4e8;">    left *Node</span></span>
<span class="line"><span style="color:#e1e4e8;">    right *Node</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">type Node struct{</span></span>
<span class="line"><span style="color:#24292e;">    left *Node</span></span>
<span class="line"><span style="color:#24292e;">    right *Node</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h2 id="内存对齐" tabindex="-1">内存对齐 <a class="header-anchor" href="#内存对齐" aria-label="Permalink to &quot;内存对齐&quot;">​</a></h2><h2 id="文章参考-推荐" tabindex="-1">文章参考/推荐 <a class="header-anchor" href="#文章参考-推荐" aria-label="Permalink to &quot;文章参考/推荐&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/ApJCdMSTydxN5zgxhzj21w" target="_blank" rel="noreferrer">详解 Go 内存对齐</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485894&amp;idx=1&amp;sn=5abe81977ccbb97891f1f6c9deea8135&amp;source=41#wechat_redirect" target="_blank" rel="noreferrer">在 Go 中恰到好处的内存对齐</a></li><li><a href="https://mp.weixin.qq.com/s/cg0pq6X1eGlm2lbD14F_bA" target="_blank" rel="noreferrer">Go 内存对齐的那些事儿</a></li></ul>`,11),r=[n];function i(o,c,p,d,h,u){return e(),l("div",null,r)}const m=a(s,[["render",i]]);export{g as __pageData,m as default};
