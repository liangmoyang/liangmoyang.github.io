import{_ as a,o as e,c as t,R as r}from"./chunks/framework.LBXiIpgL.js";const f=JSON.parse('{"title":"延时任务的实现方案","description":"","frontmatter":{},"headers":[],"relativePath":"structure/delay_task.md","filePath":"structure/delay_task.md"}'),i={name:"structure/delay_task.md"},o=r('<h1 id="延时任务的实现方案" tabindex="-1">延时任务的实现方案 <a class="header-anchor" href="#延时任务的实现方案" aria-label="Permalink to &quot;延时任务的实现方案&quot;">​</a></h1><h2 id="常见场景" tabindex="-1">常见场景 <a class="header-anchor" href="#常见场景" aria-label="Permalink to &quot;常见场景&quot;">​</a></h2><ol><li>订单超时未支付，需自动取消</li></ol><h2 id="方案一-数据库轮询" tabindex="-1">方案一：数据库轮询 <a class="header-anchor" href="#方案一-数据库轮询" aria-label="Permalink to &quot;方案一：数据库轮询&quot;">​</a></h2><p>通过一个单独的线程定时去查询扫描数据库，通过订单时间来判断是否有超时未支付的订单。</p><p>优点：简单，支持集群</p><p>缺点：内存消耗大，存在延迟，数据库压力大</p><h2 id="方案二-使用延时队列" tabindex="-1">方案二：使用延时队列 <a class="header-anchor" href="#方案二-使用延时队列" aria-label="Permalink to &quot;方案二：使用延时队列&quot;">​</a></h2><h2 id="方案三-时间轮算法" tabindex="-1">方案三：时间轮算法 <a class="header-anchor" href="#方案三-时间轮算法" aria-label="Permalink to &quot;方案三：时间轮算法&quot;">​</a></h2><h2 id="方案四-使用redis的zset" tabindex="-1">方案四：使用Redis的ZSet <a class="header-anchor" href="#方案四-使用redis的zset" aria-label="Permalink to &quot;方案四：使用Redis的ZSet&quot;">​</a></h2><h2 id="方案五-redis的keyspace-notifications" tabindex="-1">方案五：Redis的Keyspace Notifications <a class="header-anchor" href="#方案五-redis的keyspace-notifications" aria-label="Permalink to &quot;方案五：Redis的Keyspace Notifications&quot;">​</a></h2><p>该机制是在key失效之后，提供一个回调。</p><p>缺点：可靠性低。容易丢失消息</p>',13),s=[o];function d(l,n,c,h,_,p){return e(),t("div",null,s)}const k=a(i,[["render",d]]);export{f as __pageData,k as default};
