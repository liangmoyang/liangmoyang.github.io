import{_ as s,o as a,c as n,R as l}from"./chunks/framework.LBXiIpgL.js";const m=JSON.parse('{"title":"map 哈希表","description":"","frontmatter":{},"headers":[],"relativePath":"golang_review/data_type/map.md","filePath":"golang_review/data_type/map.md"}'),p={name:"golang_review/data_type/map.md"},o=l(`<h1 id="map-哈希表" tabindex="-1">map 哈希表 <a class="header-anchor" href="#map-哈希表" aria-label="Permalink to &quot;map 哈希表&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><ul><li>基于哈希表实现的</li><li>尽量不要再大map中保存指针（k/v都不包含指针），可以避免在GC期间对map进行整体扫描。 <ul><li>优化例子：<code>map[string]int</code>改为<code>map[[12]byte]int</code>。因为string底层有指针，作为key时，GC会扫描整个map；而数组<code>[12]byte</code>是一个值类型。</li></ul></li><li>删除键值对时，并不会真正删除，而是标记。随着键值对被标记越来越多，会造成内存浪费。 <ul><li>设计初衷之一是为了防止后续相同的key插入。</li></ul></li><li>只有扩容机制，没有缩容机制。（扩容机制补充）</li><li>访问数据的两种方式是通过编译器使用两个不同的内部方法实现的。<div class="language-Go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// src/runtime/hashmap.go</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mapaccess1</span><span style="color:#E1E4E8;">(t </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">maptype, h </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">hmap, key unsafe.Pointer) unsafe.Pointer</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mapaccess2</span><span style="color:#E1E4E8;">(t </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">maptype, h </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">hmap, key unsafe.Pointer) (unsafe.Pointer, </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// src/runtime/hashmap.go</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mapaccess1</span><span style="color:#24292E;">(t </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">maptype, h </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">hmap, key unsafe.Pointer) unsafe.Pointer</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mapaccess2</span><span style="color:#24292E;">(t </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">maptype, h </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">hmap, key unsafe.Pointer) (unsafe.Pointer, </span><span style="color:#D73A49;">bool</span><span style="color:#24292E;">)</span></span></code></pre></div></li></ul><h2 id="并发" tabindex="-1">并发 <a class="header-anchor" href="#并发" aria-label="Permalink to &quot;并发&quot;">​</a></h2><ul><li>原生的map是非并发安全的</li><li>并发读写会触发<code>fatal error: concurrent map read and map write</code>，由<code>runtime</code>使用<code>throw</code>抛出，无法用<code>recover</code>捕获。</li><li>通过底层实现的<code>flags</code>标志位实现检查</li><li>并发场景：使用<code>sync.Map</code>，适合读多写少。</li></ul><h2 id="底层" tabindex="-1">底层 <a class="header-anchor" href="#底层" aria-label="Permalink to &quot;底层&quot;">​</a></h2><div class="language-Go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">hmap</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    count     </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// map的大小，len()的值</span></span>
<span class="line"><span style="color:#E1E4E8;">    flags     </span><span style="color:#F97583;">uint8</span><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// 状态标识。写入和扩容机制的相关状态控制</span></span>
<span class="line"><span style="color:#E1E4E8;">    B         </span><span style="color:#F97583;">uint8</span><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// 桶，最大可容纳的元素数量。值为负载因子(默认6.5)*2^B</span></span>
<span class="line"><span style="color:#E1E4E8;">    noverflow </span><span style="color:#F97583;">uint16</span><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 溢出桶的数量</span></span>
<span class="line"><span style="color:#E1E4E8;">    hash0     </span><span style="color:#F97583;">uint32</span><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 哈希因子</span></span>
<span class="line"><span style="color:#E1E4E8;">    buckets    unsafe.Pointer	</span><span style="color:#6A737D;">// 保存当前桶数据的指针地址</span></span>
<span class="line"><span style="color:#E1E4E8;">    oldbuckets unsafe.Pointer	</span><span style="color:#6A737D;">// 保存旧桶的指针地址</span></span>
<span class="line"><span style="color:#E1E4E8;">    nevacuate  </span><span style="color:#F97583;">uintptr</span><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 迁移进度，小于该值的视为已搬迁</span></span>
<span class="line"><span style="color:#E1E4E8;">	extra </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">mapextra		</span><span style="color:#6A737D;">// 原有的bucket满载后，会发生扩容（Go中使用增量扩容）</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mapextra</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    overflow    </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">[]</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">bmap	</span><span style="color:#6A737D;">// 当前溢出桶的指针地址</span></span>
<span class="line"><span style="color:#E1E4E8;">    oldoverflow </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">[]</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">bmap	</span><span style="color:#6A737D;">// 旧的溢出桶的指针地址</span></span>
<span class="line"><span style="color:#E1E4E8;">    nextOverflow </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">bmap		</span><span style="color:#6A737D;">// 空闲溢出桶的指针地址</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">bmap</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">	tophash [bucketCnt]</span><span style="color:#F97583;">uint8</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hmap</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    count     </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">		</span><span style="color:#6A737D;">// map的大小，len()的值</span></span>
<span class="line"><span style="color:#24292E;">    flags     </span><span style="color:#D73A49;">uint8</span><span style="color:#24292E;">		</span><span style="color:#6A737D;">// 状态标识。写入和扩容机制的相关状态控制</span></span>
<span class="line"><span style="color:#24292E;">    B         </span><span style="color:#D73A49;">uint8</span><span style="color:#24292E;">		</span><span style="color:#6A737D;">// 桶，最大可容纳的元素数量。值为负载因子(默认6.5)*2^B</span></span>
<span class="line"><span style="color:#24292E;">    noverflow </span><span style="color:#D73A49;">uint16</span><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 溢出桶的数量</span></span>
<span class="line"><span style="color:#24292E;">    hash0     </span><span style="color:#D73A49;">uint32</span><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 哈希因子</span></span>
<span class="line"><span style="color:#24292E;">    buckets    unsafe.Pointer	</span><span style="color:#6A737D;">// 保存当前桶数据的指针地址</span></span>
<span class="line"><span style="color:#24292E;">    oldbuckets unsafe.Pointer	</span><span style="color:#6A737D;">// 保存旧桶的指针地址</span></span>
<span class="line"><span style="color:#24292E;">    nevacuate  </span><span style="color:#D73A49;">uintptr</span><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 迁移进度，小于该值的视为已搬迁</span></span>
<span class="line"><span style="color:#24292E;">	extra </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">mapextra		</span><span style="color:#6A737D;">// 原有的bucket满载后，会发生扩容（Go中使用增量扩容）</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mapextra</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    overflow    </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">[]</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">bmap	</span><span style="color:#6A737D;">// 当前溢出桶的指针地址</span></span>
<span class="line"><span style="color:#24292E;">    oldoverflow </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">[]</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">bmap	</span><span style="color:#6A737D;">// 旧的溢出桶的指针地址</span></span>
<span class="line"><span style="color:#24292E;">    nextOverflow </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">bmap		</span><span style="color:#6A737D;">// 空闲溢出桶的指针地址</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">bmap</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">	tophash [bucketCnt]</span><span style="color:#D73A49;">uint8</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>桶：每个桶容纳8个键值对 <ul><li>定位到某个bucket之后，还要再定位到具体的key，找到value。</li></ul></li><li>哈希因子</li><li>装载因子：通过计算得出</li><li>负载因子：硬编码6.5，由官方经测试得出。</li></ul><h2 id="扩容" tabindex="-1">扩容 <a class="header-anchor" href="#扩容" aria-label="Permalink to &quot;扩容&quot;">​</a></h2><p>桶中元素超过8个时，使用溢出桶进行存储或扩容，并与当前桶连接。 扩容的过程并不是一次完成的，这也是不支持缩容的原因之一。 没有真正的缩容机制。所以可通过新建变量，大的往小的挪动，再删除掉大的。</p><h2 id="文章参考-推荐" tabindex="-1">文章参考/推荐 <a class="header-anchor" href="#文章参考-推荐" aria-label="Permalink to &quot;文章参考/推荐&quot;">​</a></h2><ul><li><a href="https://www.51cto.com/article/720339.html" target="_blank" rel="noreferrer">Go：Map 和 内存泄露</a></li><li><a href="https://www.cnblogs.com/sunsky303/p/11815172.html" target="_blank" rel="noreferrer">你不知道的Golang map</a></li><li><a href="https://mp.weixin.qq.com/s/nmhZEkWC-xB-Fr-0gvE3hw" target="_blank" rel="noreferrer">一篇文章把 Go map 赋值和扩容扒干净！ </a></li><li><a href="https://mp.weixin.qq.com/s/iL9dgMW47q0ySTYkvfl6fg?poc_token=HALfb2Wjqn9D9CedJqa_HN0DUhrnLcSylfaPfuT3" target="_blank" rel="noreferrer">一文啃透 Go map：初始化和访问</a></li><li><a href="https://mp.weixin.qq.com/s/SGv5vuh9aU2mqViC4Kj0YQ" target="_blank" rel="noreferrer">从 map 的 extra 字段谈起</a></li><li><a href="https://mp.weixin.qq.com/s/nL7jkskVHTmCy3Ed9e-RZA" target="_blank" rel="noreferrer">面试官：为什么 Go 的负载因子是 6.5？</a></li></ul>`,12),e=[o];function t(c,r,y,i,E,u){return a(),n("div",null,e)}const d=s(p,[["render",t]]);export{m as __pageData,d as default};
